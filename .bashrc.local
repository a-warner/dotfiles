# Copied from dotmatrix hashrc

alias ll='ls -l'

# git_prompt_info accepts 0 or 1 arguments (i.e., format string)
# returns text to add to bash PS1 prompt (includes branch name)
git_prompt_info () {
  local g="$(git rev-parse --git-dir 2>/dev/null)"
  if [ -n "$g" ]; then
    local r
    local b
    local d
    local s
    # Rebasing
    if [ -d "$g/rebase-apply" ] ; then
      if test -f "$g/rebase-apply/rebasing" ; then
        r="|REBASE"
      fi
      b="$(git symbolic-ref HEAD 2>/dev/null)"
    # Interactive rebase
    elif [ -f "$g/rebase-merge/interactive" ] ; then
      r="|REBASE-i"
      b="$(cat "$g/rebase-merge/head-name")"
    # Merging
    elif [ -f "$g/MERGE_HEAD" ] ; then
      r="|MERGING"
      b="$(git symbolic-ref HEAD 2>/dev/null)"
    else
      if [ -f "$g/BISECT_LOG" ] ; then
        r="|BISECTING"
      fi
      if ! b="$(git symbolic-ref HEAD 2>/dev/null)" ; then
        if ! b="$(git describe --exact-match HEAD 2>/dev/null)" ; then
          b="$(cut -c1-7 "$g/HEAD")..."
        fi
      fi
    fi

    # Dirty Branch
    local newfile='?? '
    if [ -n "$ZSH_VERSION" ]; then
      newfile='\?\? '
    fi
    d=''
    s=$(git status --porcelain 2> /dev/null)
    [[ $s =~ "$newfile" ]] && d+='+'
    [[ $s =~ "M " ]] && d+='*'
    [[ $s =~ "D " ]] && d+='-'

    printf "${1-"(%s) "}" "${b##refs/heads/}$r$d"
  fi
}

gco () {
  if [[ $1 == '.' ]]; then
    git add -A
    git commit -m "CHECKING OUT CURRENT DIRECTORY" -q
    git reset HEAD^ -q
    git checkout .
  else
    git checkout "$@"
  fi
}

alias gap='git add -p'
alias gnap='git add -N . && git add -p'
alias gb='git branch'
alias gc='git commit -v'
alias gca='git commit -a -v'
alias gd='git diff'
alias gdc='git diff --cached'
alias gdh='git diff HEAD'
alias gl='git pull'
alias glod='git log --oneline --decorate'
alias gln="git ln | perl -ple 's/\*/sprintf(\"%2s\", \$n++)/e' | less"
alias gp='git push'
alias gpr='git pull --rebase'
alias gst='git status'
alias gr='git rebase'
alias grc='git rebase --continue'
alias gra='git rebase --abort'
alias reset-authors='git commit --amend --reset-author -C HEAD'
alias vi='vim'

# from dotmatrix bashrc

VISUAL=vim
EDITOR="$VISUAL"
LESS="FRX"
RI="--format ansi -T"
PSQL_EDITOR='vim -c"setf sql"'
CLICOLOR=1
LSCOLORS=gxgxcxdxbxegedabagacad

export VISUAL EDITOR LESS RI PSQL_EDITOR CLICOLOR LSCOLORS

bind 'set bind-tty-special-chars off'
bind '"\ep": history-search-backward'
bind '"\en": history-search-forward'
bind '"\C-w": backward-kill-word'

bind '"\C-q": "%-\n"'

[ -z "$PS1" ] || stty -ixon

[ -z "$PS1" ] || export PS1="\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;36m\]\w\[\033[00m\]\$(git_prompt_info '(%s)')\n$ "


# salvaged from my old bashrc

alias gsp="git stash pop"
alias gs="git stash"
alias gpl="git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"
alias grpe=grep
alias grep='grep --color=auto'
alias igrep="grep -i"
alias lgrep="grep --line-buffered"
alias lr='ls -lrta'
alias rdm="bundle exec rake db:migrate"
alias rdr="bundle exec rake db:rollback"
alias gphm="git push heroku master"
alias gac='gc --amend -Chead'
alias reload="source ~/.bash_profile"
alias hcurl='curl -o /dev/null -s -D - '

# pushes a new branch to origin, sets it up to track
# the remote
gpnb() {
  if [ -n "$(git rev-parse --git-dir 2>/dev/null)" ]; then
    local b="$(git symbolic-ref HEAD 2>/dev/null)"
    if [ -n "$b" ]; then
      local branch="${b##refs/heads/}"
      if [ "$branch" == "master" ]; then
        echo "Current branch is master...nothing to do."
      else
        t="$(git config branch.$branch.remote 2>/dev/null)"
        if [ -n "$t" ]; then
          echo "Branch $branch already set up to track remote \"$t\" ...nothing to do"
        else
          echo "Pushing $branch to origin and setting it up to track remote"
          local cmd="git push -u origin $branch"
          $cmd
        fi
      fi
    else
      echo "Unable to determine current branch; the git repo may be in a bad state"
      exit 1
    fi
  else
    echo "Not in a git dir...exiting."
  fi
}

getpull() {
  if [ -z "$1" ]; then
    echo "Usage: getpull <SHA>"
  elif [ -z "$(git rev-parse --git-dir 2>/dev/null)" ]; then
    echo "Not in a git directory"
  else
    local origin_url=$(git config --get remote.origin.url)
    local pull_base_url=$(ruby -e "print \"https://github.com/\" + \"$origin_url\"[/:(.+)?\.git$/, 1] + \"/pull\"")
    local pull_id=$(git log $1..master --ancestry-path --merges --oneline | grep -oP "#\d+" | tail -n 1 | grep -oP '\d+')

    if [ -n "$pull_id" ]; then
      echo "$pull_base_url/$pull_id"
    else
      echo "Sorry, couldn't find that pull"
    fi
  fi
}

complete -o default -W "\$(git branch 2>/dev/null | cut -c 3-)" git gco

if [[ $(ps -o comm= -p $PPID) != *sh ]]; then
  shopt -s histappend
  export PROMPT_COMMAND="$( [ '$PROMPT_COMMAND' ] && echo $PROMPT_COMMAND; ) history -a; history -n"
fi

# Huge history sizes
HISTSIZE=1000000000
HISTFILESIZE=1000000000
HISTFILE=~/.bash_history

# Avoid storing duplicates and space-prefixed commands
HISTCONTROL=ignoredups:ignorespace

# Append to history instead of overwriting
shopt -s histappend

# After each command:
#   - history -a  -> append this sessionâ€™s command to history file
#   - history -n  -> reload new lines from other terminals
if [[ -z "$PROMPT_COMMAND" ]]; then
    PROMPT_COMMAND="history -a; history -n"
else
    PROMPT_COMMAND="$PROMPT_COMMAND"$'\n'"history -a; history -n"
fi

[ -f ~/.fzf.bash ] && source ~/.fzf.bash
